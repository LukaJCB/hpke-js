import type { Exporter } from "./exporter.ts";

/**
 * The encryption context interface for a recipient and a sender.
 */
export interface EncryptionContextInterface extends Exporter {
  /**
   * Encrypts data.
   *
   * If the error occurred, throws `SealError` | `MessageLimitReachedError`.
   *
   * @param data A plain text as bytes to be encrypted.
   * @param aad Additional authenticated data as bytes fed by an application.
   * @returns A cipher text as bytes.
   * @throws {@link MessageLimitReachedError}, {@link SealError}
   */
  seal(data: ArrayBuffer, aad?: ArrayBuffer): Promise<ArrayBuffer>;

  /**
   * Decrypts data.
   *
   * If the error occurred, throws `OpenError`.
   *
   * @param data An encrypted text as bytes to be decrypted.
   * @param aad Additional authenticated data as bytes fed by an application.
   * @returns A decrypted plain text as bytes.
   * @throws {@link OpenError}
   */
  open(data: ArrayBuffer, aad?: ArrayBuffer): Promise<ArrayBuffer>;

  /**
   * Sets up bi-directional encryption to allow a recipient to send
   * encrypted messages to a sender. This function follows the manner
   * demonstrated in [RFC9180 Section 9.8](https://www.rfc-editor.org/rfc/rfc9180.html#section-9.8).
   *
   * If the error occurred, throws `ExportError`.
   *
   * @param keySeed A seed for generating a secret key as bytes.
   * @param nonceSeed A seed for generating a base nonce as bytes.
   * @throws {@link ExportError}
   */
  setupBidirectional(
    keySeed: ArrayBuffer,
    nonceSeed: ArrayBuffer,
  ): Promise<void>;
}

/**
 * The recipient encryption context.
 */
export type RecipientContextInterface = EncryptionContextInterface;

/**
 * The sender encryption context.
 */
export interface SenderContextInterface extends EncryptionContextInterface {
  /** The encapsulated key generated by the sender. */
  enc: ArrayBuffer;
}
